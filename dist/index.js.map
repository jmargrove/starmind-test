{"version":3,"sources":["index.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,IAAM,IAAI,GAAG,YAAA;AACX,EAAA,OAAO,CAAC,GAAR,CAAY,0BAAZ;AAEA,MAAM,KAAK,GAAG,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,EAAgB,GAAhB,EAAqB,GAArB,EAA0B,GAA1B,EAA+B,GAA/B,EAAoC,GAApC,CAAd;AACA,MAAM,MAAM,GAAa,EAAzB;;AAIA,MAAM,aAAa,GAAkB,UAAC,WAAD,EAAc,MAAd,EAAoB;AACvD;AACA,IAAA,WAAW,CAAC,OAAZ,CAAoB,MAApB;AACA,WAAO,WAAP;AACD,GAJD;;AAQA,MAAM,YAAY,GAAiB,UAAA,KAAA,EAAK;AACtC;AACA,IAAA,MAAM,CAAC,IAAP,CAAW,KAAX,CAAA,MAAA,EAAe,KAAf;AACD,GAHD;;AAKA,EAAA,YAAY,CAAC,KAAK,CAAC,MAAN,CAAa,aAAb,EAA4B,EAA5B,CAAD,CAAZ;AACA,MAAM,UAAU,GAAG,KAAK,CAAC,OAAN,GAAgB,IAAhB,CAAqB,EAArB,MAA6B,MAAM,CAAC,IAAP,CAAY,EAAZ,CAAhD;AACA,EAAA,UAAU,GACN,OAAO,CAAC,GAAR,CAAY,0BAAZ,CADM,GAEN,OAAO,CAAC,GAAR,CAAY,oBAAZ,CAFJ,CAvBW,CA2BX;AAEA;AACA;AACA;AACA;AACA;AACA;AACD,CAnCD;;AAqCA,IAAI","file":"index.js","sourceRoot":"../src","sourcesContent":["const main = () => {\n  console.log(\"watching with nodemon 🚀\");\n\n  const input = [\"s\", \"t\", \"a\", \"r\", \"m\", \"i\", \"n\", \"d\"];\n  const result: string[] = [];\n\n  type CustomReverse = (accumulator: string[], letter: string) => string[];\n\n  const customReverse: CustomReverse = (accumulator, letter) => {\n    // Task 1: Implement this function such that it reverses the array when passing it to Array.prototype.reduce.\n    accumulator.unshift(letter);\n    return accumulator;\n  };\n\n  type AssignResult = (array: string[]) => void;\n\n  const assignResult: AssignResult = array => {\n    // Task 2: Above defined \"const result\" should hold the value of array.\n    result.push(...array);\n  };\n\n  assignResult(input.reduce(customReverse, []));\n  const testPassed = input.reverse().join(\"\") === result.join(\"\");\n  testPassed\n    ? console.log(\"Test is passed!!! 😄😄😄\")\n    : console.log(\"Test Failed 😞😞😞\");\n\n  // Bonus question: Why can't we check (result === input.reverse()) to find out whether the test has passed?\n\n  // Arrays like input.reverse() and result are stored at references in the memory. This means that even though the\n  // contents maybe the same, the references are different, and they are different objects. When we array1 === and array2\n  // we test if they have the same reference essentially. The join method joins all elements of the array into a string.\n  // strings can be directly compared with each othere. Essentially, if comparing objects we need to test if they are deeply equal to\n  // each other, and therefore check the contents. Primitive types like strings and numbers have a reference in the memory and\n  // therefor they can be compared.\n};\n\nmain();\n"]}